<details>
  <summary style="cursor: pointer;"><b>English</b></summary>



</details>

<hr>

<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>

## Обобщения
* Обобщения (Generics) - способ параметризировать тип без преобразований.
* Что-то похожее на обобщения в других языках называют шаблонами типа или типами-параметрами.
* В обобщенных классах нужно создавать один или более внутренних типов (таких, которые доступны только внутри).
* Эти типы будут неопределены в коде, вместо этого, эти типы будут определены отдельно для каждого объекта.
* Таким образом, для каждого объекта могут быть определены разные типы.
* Другими словами, для каждого объекта при создании нужно определить обобщенный тип.

* По сути, обобщение это такой способ сказать, что нам не важно какой там будет тип, но мы точно знаем, что он
  точно будет один и тот же и будет определен во время создания объекта.
* Обобщения записываются в угловых скобках при создании возле его идентификатора.
* Обычно, обобщенный тип обозначается одной заглавной буквой.
* Обобщенный тип обычно должен указываться для каждого объекта во время его создания. Далее в программе, в каждом
  методе, где есть параметр либо возвращаемое значение обобщенного типа, он будет заменен на указанный при создании тип
* Но, при этом, можно создать объект обобщенного класса без указания типа. Такая форма записи называется сырой (raw).
* При сыром использовании в качестве типа всегда будет выбираться Object

* В джаве очень многие классы и интерфейсы используют обобщения
* Самыми часто используемыми будут:
  * Iterator
  * Iterable
  * Comparator - реализанты этого интерфейса могут сравнивать два объекта между собой
  * Comparable - реализанты этого интерфейса могут быть сравнены между собой.
  * Supplier
  * Consumer
  * Function
  * BiFunction
* Итератор - это специальный класс, который задает правила итерирования (прохождения) по коллекции элементов
  (массив, список и тд)
* Он позволяет не только задавать определенные правила итерирования, но и делать, например, несколько способов
  пройтись по набору элементов (например, из конца в начало)
* Но, для одного класса рекомендуется делать только один итератор.
* Для того чтобы сделать итератор, класс сначала нужно пометить как Iterable.
* После этого, создаем внутренний класс, который будет реализовывать интерфейс Iterator.
* В этом классе реализовать два метода:
  * hasNext - возвращает истину, если остались элементы, которые можно прочитать
  * next - возвращает следующий элемент и передвигает итератор на один шаг вперед.
* Помимо этого, нужно также определить, как данные из колекции попадут в итератор.
  Обычно это делается через конструктор, в который просто передается ссылка на сохраненные данные коллекции.

* Обратите внимание: Когда мы записываем угловые скобки во время наследования или реализации
  обобщенного класса или интерфейса, мы в угловых скобках используем уже существующий тип, а не создаем новый.

* Цикл for-each (для-каждого) позволяет упростить работу с коллекциями, убирая все лишние переменные и действия.
* Обратите внимание, что эти действия никуда не исчезают, они просто переносятся в итератор
* Этот цикл позволяет нам упростить и сделать работу с любой коллекцией одинаковой.
* В этом цикле нужно создать переменную, потом после двоеточия записать объект, класс которого реализует Iterable
* Читается это как "Для каждого объекта из коллекции (ваш объект) выполнять..."
* Эта часть где "выполнять..." это как раз таки тело цикла
* Другими словами, в примере
```
for (String s : greetings) {
    System.out.println(s + " world!");
}
```

String s будет новым объектом на каждой итерации, а сами значения будут предоставляться методом next
из написанного нами итератора

* Оберточные классы - это такие классы, которые были созданы для замены примитивных типов в случаях, когда
  необходимо с примитивными значениями поработать как с объектами.
* Любое примитивное значение можно "Завернуть" в ссылку на объект. Этот процесс называется боксинг (boxing)
* И наоборот, когда из ссылки на объект получаем примитивное значение, это называется анбоксинг (unboxing)

* Оберточные классы, которые существуют в Java:
  * Byte
  * Short
  * Integer
  * Long
  * Float
  * Double
  * Character
  * Boolean

* Обычно боксинг и анбоксинг происходят неявно (автоматически) при использовании оберточных классов.
* Таким образом, эти классы можно использовать точно так же как и примитивные типы.
* Обратите внимание: при явном боксинге (создании объекта вручную) нельзя использовать конструктор, вместо него
  используется статический метод соответствующего класса valueOf
* Одной из полезных функций оберточных классов является парсинг.
* Парсинг - процесс чтения строки и превращения ее части в другой тип.
* Например,
```
        String input = "125";
        int res = Integer.parseInt(input);
```

в этом коде мы распарсили строку input на число типа int, использовав оберточный класс
</details>
